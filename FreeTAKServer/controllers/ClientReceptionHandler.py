#######################################################
# 
# ClientReceptionHandler.py
# Python implementation of the Class ClientReceptionHandler
# Generated by Enterprise Architect
# Created on:      19-May-2020 7:17:21 PM
# Original author: Natha Paquette
# 
#######################################################
import time
import socket
from FreeTAKServer.controllers.CreateLoggerController import CreateLoggerController
from defusedxml import ElementTree as etree
from typing import Union

logger = CreateLoggerController("ClientReceptionHandler").getLogger()
from FreeTAKServer.controllers.configuration.ClientReceptionLoggingConstants import ClientReceptionLoggingConstants

loggingConstants = ClientReceptionLoggingConstants()


def verify_cot_string(cot_string: bytes) -> bool:
    try:
        event = etree.fromstring(cot_string)
        if event.tag == "event":
            return True

        else:
            return False
    except etree.ParseError:
        return False

def receive_data(buffer_size, part, sock) -> Union[bytes, None]:
    try:
        sock.settimeout(0.1)
        part += sock.recv(buffer_size)
        return part
    except socket.timeout:
        return None

    except BrokenPipeError as e:
        #self.disconnect_received(client, queue)
        raise e

    except Exception as e:
        logger.error("Exception other than broken pipe in monitor for data function " + str(e))
        #self.disconnect_received(client, queue)
        raise e


class ClientReceptionHandler:
    def __init__(self):
        self.dataPipe = []
        self.socketCount = 0

    def startup(self, clientInformationArray):
        try:
            self.clientInformationArray = clientInformationArray
            output = self.monitorForData(self.dataPipe)
            if output == 1:
                return self.dataPipe
            else:
                return -1
        except Exception as e:
            logger.error(loggingConstants.CLIENTRECEPTIONHANDLERSTARTUPERROR + str(e))

    def monitorForData(self, queue):
        ''' Get data from all clients within a given queue

        iterate over queue and attempt to retrieve data from each client
        '''
        try:
            for client in self.clientInformationArray:
                cot_string = b''
                timeout = time.time() + 5
                try:
                    while cot_string is not None and not verify_cot_string(cot_string) and time.time() < timeout:
                        cot_string = receive_data(buffer_size=10000, part=cot_string, sock=client.socket)
                    if cot_string is None:
                        continue
                    else:
                        self.returnReceivedData(client, cot_string, queue)
                except Exception as e:
                    self.disconnect_received(client, queue)
            return 1
        except Exception as e:
            logger.error('exception in monitor for data '+str(e))
            return -1

    def disconnect_received(self, client, queue):
        """ disconnect a client

        return information required to disconnect and remove client from the clientInformationArray
        """
        self.returnReceivedData(client, b'', queue)
        self.clientInformationArray.remove(client)
        # continue

    def returnReceivedData(self, clientInformation, data, queue):
        try:
            from FreeTAKServer.model.RawCoT import RawCoT
            # print(data)
            RawCoT = RawCoT()
            RawCoT.clientInformation = clientInformation
            RawCoT.xmlString = data
            self.dataPipe.append(RawCoT)
            return 1
        except Exception as e:
            logger.error(loggingConstants.CLIENTRECEPTIONHANDLERRETURNRECEIVEDDATAERROR + str(e))
            return -1