#######################################################
# 
# orchestrator.py
# Python implementation of the Class orchestrator
# Generated by Enterprise Architect
# Created on:      21-May-2020 12:24:48 PM
# Original author: Natha Paquette
# 
#######################################################
import os
from FreeTAKServer.controllers.ReceiveConnections import ReceiveConnections
from FreeTAKServer.controllers.ClientInformationController import ClientInformationController
from FreeTAKServer.controllers.ClientSendHandler import ClientSendHandler
from FreeTAKServer.controllers.SendClientData import SendClientData
from FreeTAKServer.controllers.DataQueueController import DataQueueController
from FreeTAKServer.controllers.ClientInformationQueueController import ClientInformationQueueController
from FreeTAKServer.controllers.ActiveThreadsController import ActiveThreadsController
from FreeTAKServer.controllers.ReceiveConnectionsProcessController import ReceiveConnectionsProcessController
from FreeTAKServer.controllers.MainSocketController import MainSocketController
from FreeTAKServer.controllers.XMLCoTController import XMLCoTController
from FreeTAKServer.controllers.AsciiController import AsciiController
from FreeTAKServer.controllers.configuration.LoggingConstants import LoggingConstants
from FreeTAKServer.controllers.configuration.DataPackageServerConstants import DataPackageServerConstants as DPConst
from FreeTAKServer.controllers.configuration.types import Types
from FreeTAKServer.model.RawCoT import RawCoT
from FreeTAKServer.controllers.SpecificCoTControllers.SendDisconnectController import SendDisconnectController
from FreeTAKServer.controllers.configuration.OrchestratorConstants import OrchestratorConstants
from FreeTAKServer.controllers.serializers.SqlAlchemyObjectController import SqlAlchemyObjectController
from FreeTAKServer.model.FTSModel.Event import Event

ascii = AsciiController().ascii
from logging.handlers import RotatingFileHandler
import logging
import importlib
import sqlite3
import socket
from selectors import SelectorKey
loggingConstants = LoggingConstants()
from FreeTAKServer.model.RawConnectionInformation import RawConnectionInformation
from FreeTAKServer.controllers.ClientReceptionHandler import ClientReceptionHandler
from FreeTAKServer.controllers.services.service_abstracts import ServerServiceAbstract
from FreeTAKServer.controllers.SendDataController import SendDataController
from FreeTAKServer.model.ClientInformation import ClientInformation
from FreeTAKServer.model.SpecificCoT.SpecificCoTAbstract import SpecificCoTAbstract
from FreeTAKServer.controllers.configuration.ReceiveConnectionsConstants import ReceiveConnectionsConstants

class Orchestrator(ServerServiceAbstract):
    #TODO: fix repeat attempts to add user
    #TODO: remove unnecessary variables
    #TODO: obsolesce client data pipe
    def __init__(self):
        log_format = logging.Formatter(loggingConstants.LOGFORMAT)
        self.logger = logging.getLogger(loggingConstants.LOGNAME)
        self.logger.setLevel(logging.DEBUG)
        self.logger.addHandler(self.newHandler(loggingConstants.DEBUGLOG, logging.DEBUG, log_format))
        self.logger.addHandler(self.newHandler(loggingConstants.ERRORLOG, logging.ERROR, log_format))
        self.logger.addHandler(self.newHandler(loggingConstants.INFOLOG, logging.INFO, log_format))
        # create necessary queues
        self.clientInformationQueue = []
        # this contains a list of all pipes which are transmitting CoT from clients
        self.pipeList = []
        # Internal Pipe used for CoT generated by the server itself
        self.internalCoTArray = []
        self.ClientReceptionHandlerEventPipe = ''
        # health check events
        self.healthCheckEventArray = []
        # instantiate controllers
        self.ActiveThreadsController = ActiveThreadsController()
        self.ClientInformationController = ClientInformationController()
        #self.ClientInformationQueueController = ClientInformationQueueController()
        self.ClientSendHandler = ClientSendHandler()
        self.DataQueueController = DataQueueController()
        self.ReceiveConnections = ReceiveConnections()
        self.ReceiveConnectionsProcessController = ReceiveConnectionsProcessController()
        self.MainSocketController = MainSocketController()
        self.XMLCoTController = XMLCoTController()
        self.SendClientData = SendClientData()
        self.KillSwitch = 0
        self.openSockets = 0
        self.openSocketsArray = []
        # selector to maintain client sockets



    # TODO implement responsibility chain
    def _define_responsibility_chain(self):
        pass

    def send_data_to_clients(self, sender: ClientInformation, data: Types.fts_object) -> None:
        """ This function when called will call subsequent controllers to handel the low level sending of data
        to connected client and data pipes respectively

        :param sender: the client sending this information
        :param data: the data being forwarded to clients
        :return None:
        """
        try:
            output = SendDataController().sendDataInQueue(sender=sender, processedCoT=data,
                                                          clientInformationQueue=self.clientInformationQueue)
            if self.checkOutput(output):
                pass
            else:
                self.logger.info("send data to client has failed")
                pass
        except Exception as e:
            self.logger.error(str(e))

        try:
            self.CoTSharePipe.put(data)
        except Exception as e:
            self.logger.error("putting data in CoT share pipe has failed "+str(e))

    def disconnect_client(self, key: SelectorKey) -> int:
        """ this function is called both externally via the command
        chain when the server disconnects a client or there is an error in the clients
        connection and internally when the client initiates the disconnect

        :param key: key of client to be disconnected
        :type key: named_tuple, required
        :raise None:
        :return int:
        """
        import selectors
        sock = key.fileobj
        try:
            try:
                self.sel.unregister(key.fileobj)
            except KeyError as e:
                self.logger.warning("exception "+str(e)+" thrown in removing selector")
                return None
            self.clientDisconnected(key.data)
            return 1
        except Exception as e:
            try:
                self.logger.warning("exception thrown disconnecting client " + str(e))
            except:
                pass
            return None

    def _receive_data_from_client(self, key: SelectorKey) -> SpecificCoTAbstract:
        # todo move out xml validation to separate function
        """ this function receives data from the passed client
        using the event tag to define the start and finish of a message
        at which point the xml is processed into a CoT python object

        :param key: the selector key to receive data from
        :raise None:
        :return SpecificCoTAbstract: returns an instance of a processed CoT object
        :rtype: SpecificCoTAbstract
        """
        try:
            from lxml import etree
            import time
            start = time.time()
            message = b""
            sock = key.fileobj
            try:
                other = sock.recv(22)
                if other != br'<?xml version="1.0"?>\n' and other != b'<?xml version="1.0" en':
                    message += other

                elif other == b'<?xml version="1.0" en':
                    sock.recv(34)

                elif other == b'TEST':
                    sock.send(b'success')
                    return None

                else:
                    pass

            except:
                return None
            while start-time.time() < 0.01:
                try:
                    # data is received until recv operation tries to block
                    data = sock.recv(1024)
                    print(data)
                    if data:
                        message += data
                    else:
                        # runs in the event a disconnect message is sent
                        self.disconnect_client(key)
                        break
                except Exception as e:
                    try:
                        etree.fromstring(message)
                    except:
                        return None
                    # the received xml string is serialized to an FTS object
                    processedCoT = self.dataReceived(xml_string=message.decode())
                    return processedCoT
            self.logger.debug("timeout of receive data triggered")
            return None
        except Exception as e:
            self.logger.warning("warning in receiving data from client "+str(e))
            return None

    def _accept_connection(self, key: SelectorKey) -> int:
        """ accepts and process new connections this method is responsible for the processing of all new client connections and calls
            sub methods which handle the different aspects of this process
            :param key: a selector key which will be used to accept the connection and create associated object

            :return int: indicates whether the operation was successful"""
        import selectors
        try:
            conn, addr = key.fileobj.accept()
        except Exception as e:
            self.logger.warning("client connection failed "+str(e))
            return -1
        try:
            print("client connected")
            conn.settimeout(1)
            basicConnInfo = RawConnectionInformation()
            basicConnInfo.xmlString = conn.recv(4096).decode("utf-8")
            if basicConnInfo.xmlString == ReceiveConnectionsConstants().TESTDATA:
                conn.send(b'success')
                return None
            else:
                pass
            conn.setblocking(False)
            basicConnInfo.ip = addr[0]
            basicConnInfo.socket = conn
            client_object = self.clientConnected(basicConnInfo)
            # add to selector
            events = selectors.EVENT_READ | selectors.EVENT_WRITE
            self.sel.register(conn, events, data=client_object)
            self.sendInternalCoT(client_object)
            output = SendDataController().sendDataInQueue(client_object, client_object,
                                                          self.clientInformationQueue, self.CoTSharePipe)
            if self.checkOutput(output):
                return 1
            else:
                return None
        except Exception as e:
            self.logger.warning("issue creating newly connected client data "+str(e))

    def clear_user_table(self):
        self.dbController.remove_user()
        print('user table cleared')

    def testing(self):
        """
        function which creates variables for testing
        """
        return None

    def newHandler(self, filename, log_level, log_format):
        handler = RotatingFileHandler(
            filename,
            maxBytes=loggingConstants.MAXFILESIZE,
            backupCount=loggingConstants.BACKUPCOUNT
        )
        handler.setFormatter(log_format)
        handler.setLevel(log_level)
        return handler

    def sendUserConnectionGeoChat(self, clientInformation):
        # TODO: refactor as it has a proper implementation of a PM to a user generated by the server
        """
        function to create and send pm to connecting user
        :param clientInformation:
        :return:
        """
        from FreeTAKServer.controllers.SpecificCoTControllers.SendGeoChatController import SendGeoChatController
        from FreeTAKServer.model.RawCoT import RawCoT
        from FreeTAKServer.model.FTSModel.Dest import Dest
        import uuid
        if OrchestratorConstants().DEFAULTCONNECTIONGEOCHATOBJ != None:
            ChatObj = RawCoT()
            ChatObj.xmlString = f'<event><point/><detail><remarks>{OrchestratorConstants().DEFAULTCONNECTIONGEOCHATOBJ}</remarks><marti><dest/></marti></detail></event>'
            classobj = SendGeoChatController(ChatObj)
            instobj = classobj.getObject()
            instobj.modelObject.detail._chat.chatgrp.setuid1(clientInformation.modelObject.uid)
            dest = Dest()
            dest.setcallsign(clientInformation.modelObject.detail.contact.callsign)
            instobj.modelObject.detail.marti.setdest(dest)
            instobj.modelObject.detail._chat.setchatroom(clientInformation.modelObject.detail.contact.callsign)
            instobj.modelObject.detail._chat.setparent("RootContactGroup")
            instobj.modelObject.detail._chat.setid(clientInformation.modelObject.uid)
            instobj.modelObject.detail._chat.setgroupOwner("True")
            instobj.modelObject.detail.remarks.setto(clientInformation.modelObject.uid)
            instobj.modelObject.setuid('GeoChat.'+'SERVER-UID.'+clientInformation.modelObject.detail.contact.callsign+'.'+str(uuid.uuid1()))
            instobj.modelObject.detail._chat.chatgrp.setid(clientInformation.modelObject.uid)
            classobj.reloadXmlString()
            SendDataController().sendDataInQueue(None, instobj, self.clientInformationQueue)
            return 1
        else:
            return 1

    def clientConnected(self, rawConnectionInformation):
        try:
            # temporarily broken
            # self.check_for_dead_sockets()
            from FreeTAKServer.controllers.DatabaseControllers.EventTableController import EventTableController
            clientPipe = None
            self.logger.info(loggingConstants.CLIENTCONNECTED)
            clientInformation = self.ClientInformationController.intstantiateClientInformationModelFromConnection(
                rawConnectionInformation, clientPipe)
            if self.checkOutput(clientInformation):
                pass
            else:
                raise Exception('error in the creation of client information')
            self.openSockets += 1
            #breaks ssl
            #self.ClientInformationQueueController.addClientToQueue(clientInformation)
            self.clientInformationQueue.append(clientInformation)

            # DataBase interaction
            try:
                if hasattr(clientInformation.socket, 'getpeercert'):
                    cn = "placeholder"
                else:
                    cn = None
                CoTRow = EventTableController().convert_model_to_row(clientInformation.modelObject)
                self.dbController.create_user(uid = clientInformation.modelObject.uid, callsign = clientInformation.modelObject.detail.contact.callsign, IP=clientInformation.IP, CoT = CoTRow, CN = cn)
            except Exception as e:
                print(e)
                self.logger.error(
                    'there has been an error in a clients connection while adding information to the database ' +
                    str(e))
            self.logger.info(loggingConstants.CLIENTCONNECTEDFINISHED + str(clientInformation.modelObject.detail.contact.callsign))
            sock = clientInformation.socket
            clientInformation.socket = None
            # add client to client pipe
            self.clientDataPipe.put(['add', clientInformation, self.openSockets])
            clientInformation.socket = sock
            # send connection message
            self.sendUserConnectionGeoChat(clientInformation)
            return clientInformation
        except Exception as e:
            self.logger.warning(loggingConstants.CLIENTCONNECTEDERROR + str(e))
            return -1

    def check_for_dead_sockets(self):
        # fix function
        try:
            for sock in self.clientInformationQueue:
                if sock.is_alive():
                    pass
                else:
                    self.clientDisconnected(sock)
            return 1
        except Exception as e:
            self.logger.error("there has been an exception in checking for dead sockets " + str(e))
            return -1

    def emergencyReceived(self, processedCoT):
        try:
            if processedCoT.status == loggingConstants.ON:
                self.internalCoTArray.append(processedCoT)
                self.logger.debug(loggingConstants.EMERGENCYCREATED)
            elif processedCoT.status == loggingConstants.OFF:
                for CoT in self.internalCoTArray:
                    if CoT.type == "Emergency" and CoT.modelObject.uid == processedCoT.modelObject.uid:
                        self.internalCoTArray.remove(CoT)
                        self.logger.debug(loggingConstants.EMERGENCYREMOVED)
        except Exception as e:
            self.logger.error(loggingConstants.EMERGENCYRECEIVEDERROR + str(e))

    def dataReceived(self, xml_string: str):
        """ this function processes xml_string into CoT python objects

        :param xml_string: xml_string of CoT to be processed"""
        from FreeTAKServer.model.RawCoT import RawCoT
        try:
            raw_cot = RawCoT()
            raw_cot.xmlString = xml_string
            # this will check if the CoT is applicable to any specific controllers
            CoTSerializer = self.XMLCoTController.determineCoTType(raw_cot)
            #TODO: improve way in which the dbController is passed to CoTSerializer
            raw_cot.dbController = self.dbController
            processedCoT = CoTSerializer(raw_cot).getObject()
            sender = processedCoT.clientInformation
            return processedCoT
        except Exception as e:
            self.logger.error(loggingConstants.DATARECEIVEDERROR + str(e))
            return -1

    def sendInternalCoT(self, client):
        try:
            if len(self.internalCoTArray) > 0:
                for processedCoT in self.internalCoTArray:
                    SendDataController().sendDataInQueue(processedCoT.clientInformation, processedCoT, [client])
            else:
                pass
            self.send_active_emergencys(client)
            return 1
        except Exception as e:
            self.logger.error(loggingConstants.MONITORRAWCOTERRORINTERNALSCANERROR + str(e))
            return -1

    def send_active_emergencys(self, client):
        """
        this function needs to be cleaned up however it's functionality is as follows
        it query's the DB for active emergency's at which point it iterates over all
        emergency objects, transforms them into model objects and then xmlStrings
        finally the object is sent to the client.
        """
        try:

            from FreeTAKServer.model.SpecificCoT.SendEmergency import SendEmergency
            emergencys = self.dbController.query_ActiveEmergency()
            for emergency in emergencys:
                emergencyobj = SendEmergency()
                modelObject = Event.emergecyOn()

                filledModelObject = SqlAlchemyObjectController().convert_sqlalchemy_to_modelobject(emergency.event, modelObject)
                emergencyobj.setXmlString(XMLCoTController().serialize_model_to_CoT(filledModelObject))
                emergencyobj.setModelObject(filledModelObject)
                SendDataController().sendDataInQueue(None, emergencyobj, [client])

        except Exception as e:
            self.logger.error('an exception has been thrown in sending active emergencies ' + str(e))

    def clientDisconnected(self, clientInformation):
        # TODO this should be moved out into several functions
        if hasattr(clientInformation, 'clientInformation'):
            clientInformation = clientInformation.clientInformation
        else:
            pass
        try:
            try:
                self.ActiveThreadsController.removeClientThread(clientInformation)
                self.dbController.remove_user(query=f'uid == "{clientInformation.modelObject.uid}"')
            except Exception as e:
                self.logger.error('there has been an error in a clients disconnection while adding information to the database')
                pass
            try:
                self.openSockets -= 1
                socketa = clientInformation.socket
                clientInformation.socket = None
                self.clientDataPipe.put(['remove', clientInformation, self.openSockets])
                clientInformation.socket = socketa
            except Exception as e:
                pass
            try:
                clientInformation.socket.shutdown(socket.SHUT_RDWR)
            except Exception as e:
                self.logger.error('error shutting socket down in client disconnection')
                pass
            try:
                clientInformation.socket.close()
            except Exception as e:
                self.logger.error('error closing socket in client disconnection')
                pass

            self.logger.info(loggingConstants.CLIENTDISCONNECTSTART)
            for client in self.clientInformationQueue:
                if client.ID == clientInformation.ID:
                    self.clientInformationQueue.remove(client)
                else:
                    pass
            try:
                self.ActiveThreadsController.removeClientThread(clientInformation)
                self.dbController.remove_user(query=f'uid == "{clientInformation.modelObject.uid}"')
            except Exception as e:
                self.logger.error('there has been an error in a clients disconnection while adding information to the database')
                pass
            # TODO: remove string
            tempXml = RawCoT()
            tempXml.xmlString = '<event><detail><link uid="{0}"/></detail></event>'.format(clientInformation.modelObject.uid).encode()
            disconnect = SendDisconnectController(tempXml)
            SendDataController().sendDataInQueue(disconnect.getObject().clientInformation, disconnect.getObject(), self.clientInformationQueue, self.CoTSharePipe)
            self.logger.info(loggingConstants.CLIENTDISCONNECTEND + str(clientInformation.modelObject.detail.contact.callsign))
            return 1
        except Exception as e:
            try:
                self.logger.error(loggingConstants.CLIENTCONNECTEDERROR + " " + str(e))
            except:
                pass
            pass

    def monitorRawCoT(self, data):
        """
        :param
        """
        try:
            if isinstance(data, int):
                return None
            else:
                CoT = XMLCoTController().determineCoTGeneral(data)
                function = getattr(self, CoT[0])
                output = function(CoT[1])
                return output
        except Exception as e:
            self.logger.error(loggingConstants.MONITORRAWCOTERRORB + str(e))
            return -1

    def checkOutput(self, output):
        if output != -1 and output != None:
            return True
        else:
            return False

    def loadAscii(self):
        ascii()

    def mainRunFunction(self, clientData, receiveConnection, sock, pool, event, clientDataPipe, ReceiveConnectionKillSwitch, CoTSharePipe, ssl = False):
        print('server started')
        import datetime
        receiveconntimeoutcount = datetime.datetime.now()
        lastprint = datetime.datetime.now()
        while event.is_set():
            self.CoTSharePipe = CoTSharePipe
            try:
                if ssl == True:
                    pass
                self.clientDataPipe = clientDataPipe
                if event.is_set():
                    try:
                        events = self.sel.select(timeout=1)
                        for key, mask in events:
                            if key.data is None:
                                self._accept_connection(key)
                            else:
                                client_data = self._receive_data_from_client(key)
                                if client_data:
                                    self.handel_regular_data([client_data])
                                else:
                                    pass
                    except Exception as e:
                        self.logger.error("exception thrown in handling client socket "+str(e))

                    try:
                        if not CoTSharePipe.empty():
                            data = CoTSharePipe.get()
                            CoTOutput = self.handel_shared_data(data)
                        else:
                            pass
                    except Exception as e:
                        self.logger.error('there has been an excepion in the handling of data supplied by the rest API '+str(e))
                        pass
                else:
                    self.stop()
                    break
            except Exception as e:
                self.logger.info('there has been an uncaught error thrown in mainRunFunction' + str(e))
                pass
        self.stop()

    def handel_shared_data(self, modelData):
        try:
            # print('data received within orchestrator '+str(modelData.xmlString))
            if hasattr(modelData, 'clientInformation'):
                output = SendDataController().sendDataInQueue(modelData.clientInformation, modelData,
                                                              self.clientInformationQueue)
            #

            elif modelData.type == "connmessage":
                self.internalCoTArray.append(modelData)

            # this runs in the event of a new connection
            else:
                output = SendDataController().sendDataInQueue(None, modelData,
                                                              self.clientInformationQueue)
        except Exception as e:
            print(e)

    def handel_regular_data(self, clientDataOutput):
        try:
            for clientDataOutputSingle in clientDataOutput:
                try:
                    print('handling reg data')
                    output = SendDataController().sendDataInQueue(clientDataOutputSingle.clientInformation, clientDataOutputSingle,
                                                                  self.clientInformationQueue, self.CoTSharePipe)
                    if self.checkOutput(output) and isinstance(output, tuple) == False:
                        pass
                    elif isinstance(output, tuple):
                        self.logger.error('issue sending data to client now disconnecting')
                        self.clientDisconnected(output[1])

                    else:
                        self.logger.error('send data failed in main run function with data ' + str(
                            clientDataOutput.xmlString) + ' from client ' + clientDataOutputSingle.clientInformation.modelObject.detail.contact.callsign)

                except Exception as e:
                     self.logger.info(
                        'exception in client data, data processing within main run function ' + str(
                            e) + ' data is ' + str(clientDataOutputSingle))
                     pass
                return 1
        except Exception as e:
            self.logger.info("there has been an error iterating client data output " + str(e))
            return -1

    def handel_connection_data(self, receiveConnectionOutput: RawConnectionInformation) -> int:
        """this method sends the newly connected clients information to all connected clients and calls the InternalCoT method
        to send the internal CoT data to the client"""
        try:
            if receiveConnectionOutput == -1:
                return 1

            CoTOutput = self.monitorRawCoT(receiveConnectionOutput)
            if CoTOutput != -1 and CoTOutput != None:
                output = SendDataController().sendDataInQueue(CoTOutput, CoTOutput,
                                                              self.clientInformationQueue, self.CoTSharePipe)
                if self.checkOutput(output):
                    self.logger.debug('connection data from client ' + str(
                        CoTOutput.modelObject.detail.contact.callsign) + ' successfully processed')
                else:
                    raise Exception('error in sending data')
            else:
                pass
        except Exception as e:
            self.logger.error('exception in receive connection data processing within main run function ' + str(
                e) + ' data is ' + str(CoTOutput))
            return -1
        self.sendInternalCoT(CoTOutput)
        return 1

    def start(self, IP, CoTPort, Event, clientDataPipe, ReceiveConnectionKillSwitch, RestAPIPipe):
        try:
            raise NotImplemented
        except Exception as e:
            self.logger.critical('there has been a critical error in the startup of FTS' + str(e))
            return -1

    def stop(self):
        self.clientDataPipe.close()
        self.sel.close()



"""if __name__ == "__main__":

    parser = argparse.ArgumentParser(description=OrchestratorConstants().FULLDESC)
    parser.add_argument(OrchestratorConstants().COTPORTARG, type=int, help=OrchestratorConstants().COTPORTDESC,
                        default=OrchestratorConstants().COTPORT)
    parser.add_argument(OrchestratorConstants().IPARG, type=str, help=OrchestratorConstants().IPDESC,
                        default=OrchestratorConstants().IP)
    parser.add_argument(OrchestratorConstants().APIPORTARG, type=int, help=OrchestratorConstants().APIPORTDESC,
                        default=DataPackageServerConstants().APIPORT)
    args = parser.parse_args()
    CreateStartupFilesController()
    Orchestrator().start(args.IP, args.CoTPort, args.APIPort)"""