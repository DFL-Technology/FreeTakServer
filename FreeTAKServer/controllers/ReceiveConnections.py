#######################################################
# 
# ReceiveConnections.py
# Python implementation of the Class ReceiveConnections
# Generated by Enterprise Architect
# Created on:      19-May-2020 6:21:05 PM
# Original author: Natha Paquette
# 
#######################################################
import socket
from FreeTAKServer.controllers.configuration.LoggingConstants import LoggingConstants
from FreeTAKServer.model.RawConnectionInformation import RawConnectionInformation as sat
from FreeTAKServer.controllers.CreateLoggerController import CreateLoggerController
from FreeTAKServer.controllers.configuration.ReceiveConnectionsConstants import ReceiveConnectionsConstants
from FreeTAKServer.controllers.SSLSocketController import SSLSocketController
loggingConstants = LoggingConstants()
logger = CreateLoggerController("ReceiveConnections").getLogger()
import logging
import logging.handlers
import ssl
import time
#TODO: move health check values to constants and create controller for HealthCheck data

class ReceiveConnections:
    def __init__(self):
        pass


    def listen(self, sock, sslstatus = False):
        sock.listen(0)
        try:
            if sslstatus == True:
                sock.settimeout(60)
            try:
                address, client = self.accept_connection(sock, sslstatus)
            except ssl.SSLError as e:
                print(e)
                client.close()
                logger.warning('ssl error thrown in connection attempt '+str(e))
                return -1
            except socket.timeout:
                return -1
            if sslstatus == True:
                logger.info('client connected over ssl ' + str(address) + ' ' + str(time.time()))
            #wait to receive client
            data = self.receive_initial_data(client)
            client.settimeout(0)
            logger.info(loggingConstants.RECEIVECONNECTIONSLISTENINFO)
            raw_connection_information = self.build_connection_information(address, client, data)
            return raw_connection_information

        except Exception as e:
            client.close()
            logger.warning(loggingConstants.RECEIVECONNECTIONSLISTENERROR+str(e))
            return -1

    def build_connection_information(self, address, client, data):
        raw_connection_information = sat()
        raw_connection_information.ip = address[0]
        raw_connection_information.socket = client
        raw_connection_information.xmlString = data.decode('utf-8')
        return raw_connection_information

    def receive_initial_data(self, client):
        client.settimeout(int(ReceiveConnectionsConstants().RECEIVECONNECTIONDATATIMEOUT))
        data = client.recv(1024)
        if data == ReceiveConnectionsConstants().TESTDATA:
            client.send(b'success')
        else:
            pass
        return data

    def accept_connection(self, sock, sslstatus):
        client, address = sock.accept()
        if sslstatus == True:
            client = SSLSocketController().wrap_client_socket(client)
        return address, client
